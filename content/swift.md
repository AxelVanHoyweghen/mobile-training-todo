---

---

# Design

## Data Modeling

In this lesson you will learn how to model the data for an application and the relationships between the different models.

Initially, the schema for a todo list application may look like the table below.

|List|Task|
|:---|:---|
|name|name|
|owner|complete|

With the following schema relationships:

1. A task belongs to a list.
2. A list belongs to a user.

Throughout this lesson you will extend this basic data model to meet the requirements of the application.

### From Tables to JSON

Couchbase Mobile stores data in documents rather than in table rows. A document is a JSON object containing a number of key-value pairs. This means that it can take any form as long as it is [valid JSON](http://www.json.org/). The following image represents the same schema as the table above but in JSON format.

![](img/03-types.png)

We use the `type` property to store the entity type on each document.

### Storing Dates

Another requirement of the application is to sort tasks by the time they were created at. JSON itself does not specify how dates should be represented. To keep chronological ordering with string dates, they should be stored in ISO-8601 format (YYYY-MM-DDThh:mm:ssZ). The following diagram adds a `createdAt` field on the **task** document with the date in ISO-8601 format.

![](img/04-dates.png)

### Document IDs

The document ID is the primary identifier of a document in the database. It can be pre-defined by the application or automatically generated by the database during a write operation. It is unique in the system and does not change throughout the lifecycle of a document (CRUD operations). The image below adds unique document IDs on the List and Task models..

![](img/05-ids.png)

> **Note:** You may notice that the document ID on the List model is prefixed with the owner. This design choice will be discussed in detail in the [Access Control](/documentation/mobile/1.3/training/design/security/index.html) lesson.

### Entity relationship

There is a one-to-many relationship between the List and Task documents. A List can hold several Tasks but a Task can only belong to one List. In Couchbase Mobile, relationships between different entities (1:1, 1:many and many:many) are implemented by keeping a reference from the child to the parent model. The document ID serves as the reference (foreign key) since it is unique and doesn't change. The image below adds a `list` property on the Task model.

![](img/06-reference.png)

### Attachments

Tasks can have an image attached to them. Attachments are also persisted to disc and synchronized with the document they belong to. The following diagram adds an attachment called `photo` of type `image/jpg` to the Task model.

![](img/06-attachment.png)

> **Note:** All the fields that start with "\_" are Couchbase specific (i.e `_id`, `_attachments`). For this reason, it is not recommended to name your own properties with a leading underscore.

### Conclusion

Well done! You've completed this lesson on modeling the data in different documents and the relationships between them. In the next lesson you'll learn how to design the security model for each type of document. Feel free to share your feedback, findings or ask any questions on the forums.

## Security

In this lesson you’ll learn how to secure your data model using Couchbase Mobile’s built-in security framework.

Security rules are used to determine who has read and write access to the database. They live on the server in Sync Gateway and are enforced at all times.

The access control requirements for the application are the following.

1. A user can create a list and tasks.
2. The owner of a list can invite other users to access the list.
3. Users invited to a list can create tasks.
4. A moderator has access to all lists.
5. A moderator can create new tasks and invte users.

### Routing

Sync Gateway provides an ability to assign documents to something we call channels. You control assigning documents to channels through the Sync Function. The image below specifies that the List and Task documents are assigned to the same channel ("list.user1.dk39-4kd9-lw9d").

![](img/02-list-channel.png)

### Read Access

#### Single user

Once the document is mapped to the channel you can give the user access to it. In doing so, that user will have read access to all the documents in the channel. The following image specifies the `access` call to grant read access to the list channel.

![](img/03-read-access.png)

> **Tip:** As shown above, you can route documents of different types to the same channel. The `access` method can then be invoked once since the list and its tasks are in the same channel.

#### Multiple users

Now let's consider the action of sharing a list with another user. Currently, List and Task models do not have an option to specify other user names.

In the application, there is no limit to how many users can access a list. There could be thousands! So instead of embedding other user's details on the List model we'll introduce a 3rd document that joins a list and user. The image below adds the List User model. When processing a document of type "list-user", the Sync Function must grant the user (`doc.name`) access to the list (`doc.list`).

![](img/04-multiple-users.png)

### Write Access

Write access security rules are necessary to protect the system. Generally that means checking that the user is allowed to perform the operation before persisting the document to disc.

#### By user

The image below adds a rule to ensure that only the List owner can persist those documents.

![](img/05-write-by-user.png)

The List model is the straightforward case, it checks that the user synchronizing the document is indeed the owner of the list (`doc.owner`).

For List User and Task documents the same security can be enforced because the owner is prefixed on the List document ID ("user1.dk39-4kd9-lw9d").

#### By Access

The image below adds a rule to allow invited users to create tasks. If the user sending the task has access to the list channel ("user1.dk39-4kd9-lw9d") then it must have been invited and therefore can persist the task.

![](img/06-write-by-access.png)

### Roles

Another design requirement of the application is that certain users can be moderators. In that case they can perform more operations than other non-moderating users. A user can be elected to be a moderator by users with the admin role only.

The image below adds a new Moderator model for this purpose.

![](img/07-role.png)

The following security changes to routing, read and write permissions were added.

- List, List User and Task documents are routed to the "moderators" channel.
- Moderators have access to all the lists and can create new tasks or invite users.

### Conclusion

Well done! You've completed this lesson on designing the security model for each scenario in the application. In the next lesson you'll learn how to create an empty database to store documents. Feel free to share your feedback, findings or ask any questions on the forums.

# Develop

## Create a Database

### New database

The entrypoint in the Couchbase Lite SDK is the [Manager](/documentation/mobile/current/develop/guides/couchbase-lite/native-api/manager/index.html) class. There is no limit to how many databases can be created or opened on the device. You can think of a database as a namespace for documents and several databases can be used in the same app (one database per user of the app is a common pattern). The code below creates an empty database.

```swift
// This code can be found in AppDelegate.swift
// in the openDatabase(username:withKey:withNewKey) method
let dbname = username
let options = CBLDatabaseOptions()
options.create = true

if kEncryptionEnabled {
		if let encryptionKey = key {
				options.encryptionKey = encryptionKey
		}
}

try database = CBLManager.sharedInstance().openDatabaseNamed(dbname, with: options)
```

Here you're using the `openDatabaseNamed` method where the database is the user currently logged in and `options.create` is set to `true`.

> **Note:** You can ignore the encryption flag. Database encryption will be covered in the [Adding Security](/documentation/mobile/1.3/training/design/security/index.html) lesson.

#### Try it out

1. Build and run.
2. Create a new list on the application's 'Task lists' screen.
3. The task list is persisted to the database.

<img src="img/image40.png" class="portrait" />

### Pre-built database

In this section, you will learn how to bundle a pre-built Couchbase Lite database in an application. It can be a lot more efficient to bundle a database in your application and install it on the first launch. Even if some of the content changes on the server after you create the app, the app's first pull replication will bring the database up to date. Here, you will use a pre-built database that contains a list of groceries. The code below moves the pre-built database from the bundled location to the application directory.

```swift
// This code can be found in AppDelegate.swift
// in the installPrebuiltDb() method
guard kUsePrebuiltDb else {
		return
}

let db = CBLManager.sharedInstance().databaseExistsNamed("todo")

if (!db) {
		let dbPath = Bundle.main.path(forResource: "todo", ofType: "cblite2")
		do {
				try CBLManager.sharedInstance().replaceDatabaseNamed("todo", withDatabaseDir: dbPath!)
		} catch let error as NSError {
				NSLog("Cannot replace the database %@", error)
		}
}
```

The prebuilt database is installed using the database replacement API only if there isn't any existing database called 'todo'. Since you created an empty database called 'todo' in the previous step you must first remove the existing database.

#### Try it out

1. Open **AppDelegate.swift** and set the `kUsePrebuiltDb` constant to `true`.

		```swift
		let kUsePrebuiltDb = true
		```

2. Build and run (⚠️ don't forget to delete the app first).
3. A Groceries list will now be visible on the Lists screen. Click on it to see the tasks.
	<img src="https://cl.ly/3e1J2I0G1U1U/image45.gif" class="portrait" />

#### Conclusion

Well done! You've completed this lesson on creating a database. In the next lesson you will learn how to write and query documents from the database. Feel free to share your feedback, findings or ask any questions on the forums.

## Using the Database

### Create Document

In this lesson you’ll be introduced to Couchbase Lite, our embedded NoSQL database. You’ll learn how to create, read, update, delete, and query data using Couchbase Lite.

> **Tip:** To make things a bit more exciting, you may want to use the pre-built database containing a list of Groceries. Refer to the [Create a Database](/documentation/mobile/1.3/training/develop/create-database/index.html) lesson to learn how to use it.

### Create a Document

In Couchbase Lite, the primary entity stored in a database is called a document instead of a "row" or "record". A document's body takes the form of a JSON object — a collection of key/value pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects. The code below creates a new list document.

```swift
// This code can be found in ListsViewController.swift
// in the createTaskList(name:) method
let properties: [String : Any] = [
		"type": "task-list",
		"name": name,
		"owner": username
]

let docId = username + "." + NSUUID().uuidString
guard let doc = database.document(withID: docId) else {
		Ui.showMessageDialog(onController: self, withTitle: "Error",
				withMessage: "Couldn't save task list")
		return nil
}

do {
		return try doc.putProperties(properties)
} catch let error as NSError {
		Ui.showMessageDialog(onController: self, withTitle: "Error",
				withMessage: "Couldn't save task list", withError: error)
		return nil
}
```

Here you're creating an unsaved document instance with a pre-defined **document ID** (i.e. the **_id** property in the document’s JSON body) using the `documentWithID` method. The ID follows the form `{username}.{uuid}` where username is the name of the user logged in. Alternatively, you could also use the `createDocument` method to let the database generate a random **ID** for you.

#### Try it out

1. Build and run.
2. Create a new list using the '+' button on the application's 'Task lists' screen.
3. A new list document is saved to the database.
		<img src="img/image40.png" class="portrait" />
		

> **Challenge:** Update the code to persist your name as the value for the `name` field. Then create a new list and notice that your name is displayed instead of the text input value.

### Update Document

To update a document, you must retrieve it from the database, modify the desired properties and write them back to the database. The `update` method does this operation for you in the form of a callback. The code below updates a list's name property.

```swift
// This code can be found in ListsViewController.swift
// in the updateTaskList(list:withName:) method
do {
		try list.update { newRev in
				newRev["name"] = name
				return true
		}
} catch let error as NSError {
		Ui.showMessageDialog(onController: self, withTitle: "Error",
				withMessage: "Couldn't update task list", withError: error)
}
```

Your callback code can modify this object's properties as it sees fit; after it returns, the modified revision is saved and becomes the current one.

#### Try it out
              
1. Build and run.
2. Swipe to the left on a row to reveal the **Edit** button and update the List name in the pop-up.
		<img src="img/image04.png" class="portrait" />
		
> **Challenge:** Modify the code to uppercase the text inserted before persisting the document to the database.

### Delete Document

A document can be deleted using the `delete` method. This operation actually creates a new revision in order to propagate the deletion to other clients. The concept of revisions will be covered in more detail in the next lesson. The code below deletes a list.

```swift
// This code can be found in ListsViewController.swift
// in the deleteTaskList(list:) method
do {
		try list.delete()
} catch let error as NSError {
		Ui.showMessageDialog(onController: self, withTitle: "Error",
				withMessage: "Couldn't delete task list", withError: error)
}
```

> **Challenge:** Add a document change listener to detect when the document gets deleted. The [document change notification](/documentation/mobile/1.3/develop/guides/couchbase-lite/native-api/document/index.html#document-change-notifications) documentation will be helpful for this challenge.

#### Try it out

1. Build and run.
2. Click the **Delete** action to delete a list.
		<img class="portrait" src="https://cl.ly/383h2q2C2Z3V/image46.gif" />
		
### Query Documents

The way to query data in Couchbase Lite is by registering a View and then running a Query on it with QueryOptions. The first thing to know about Couchbase Views is that they have nothing to do with UI views.

A [View](/documentation/mobile/current/develop/guides/couchbase-lite/native-api/view/index.html) in Couchbase is a persistent index of documents in a database, which you then query to find data. The main component of a View is its map function. It takes a document’s JSON as input, and emits (outputs) any number of key/value pairs to be indexed. First, you will define the view to index the documents of type **task-list**. The diagram below shows the result of the code you will review shortly.

![](img/img.001.png)

So you can remember that a view index is a list of key/value pairs, sorted by key. In addition, the view’s logic is written in the native language of the platform you’re developing on. The code below indexes documents as shown on the diagram above. Then it create the Query and monitors the result set using a Live Query.

```swift
// This code can be found in ListsViewController.swift
// in the setupViewAndQuery method
let listsView = database.viewNamed("list/listsByName")
if listsView.mapBlock == nil {
		listsView.setMapBlock({ (doc, emit) in
				if let type: String = doc["type"] as? String, let name = doc["name"]
						, type == "task-list" {
								emit(name, nil)
				}
		}, version: "1.0")
}

listsLiveQuery = listsView.createQuery().asLive()
listsLiveQuery.addObserver(self, forKeyPath: "rows", options: .new, context: nil)
listsLiveQuery.start()
```

The `viewNamed` method returns a [View](http://developer.couchbase.com/documentation/mobile/current/develop/guides/couchbase-lite/native-api/view/index.html) object on which the map function can be set. The map function is indexing documents where the type property is equal to "task-list". Each cell on the screen will contain a list name and nothing else. For that reason, you can emit the name property as the key and nil is the value. If you also wanted to display the owner of the list in the row you could emit the `owner` property as the value.

The `listsView.createQuery()` method returns a [Query](/documentation/mobile/current/develop/guides/couchbase-lite/native-api/query/index.html) object which has a **run** method to return the results as a [QueryEnumerator](/documentation/mobile/current/develop/references/couchbase-lite/couchbase-lite/query/query-enumerator/index.html) object. However, in this case, you are hooking into a [Live Query](/documentation/mobile/current/develop/guides/couchbase-lite/native-api/query/index.html) to keep monitoring the database for new results. Any time the result of that query changes through user interaction or synchronization, it will notify your application via the change event. A live query provides an easy way to build reactive UIs, which will be especially useful when you enable sync in the [Adding Synchronization](/documentation/mobile/current/training/develop/adding-synchronization/index.html) lesson. The change event is triggered as a result of user interaction locally as well as during synchronization with Sync Gateway.

In the code blow, the notifications are posted to the application code using the KVO observer method.

```swift
// This code can be found in ListsViewController.swift
// in the observeValue(forKeyPath:of:_:_:) method
override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
		if object as? NSObject == listsLiveQuery {
				reloadTaskLists()
		} else if object as? NSObject == incompTasksCountsLiveQuery {
				reloadIncompleteTasksCounts()
		}
}
```

#### Try it out

1. Build and run.
2. Save a new list to the database and the live query will pick it up instantly and reload the table view.

<img src="https://cl.ly/3z3i0k1C2W1p/image66.gif" class="portrait" />

> **Challenge:** Update the map function to emit the document ID as the key. Don't forget to bump the view version whenever you change the map function. The list view should now display the document ID on each row.

### Aggregating Data
              
A problem in typical applications is how to perform data aggregation. Couchbase Lite lets you run those data queries using the full capabilities of map/reduce. To run aggregation queries on the rows emitted by the map function, you can use the reduce function which is the part of map/reduce that takes several rows from the index and aggregates them together in a single object.

Let’s write a view to query and display the number of uncompleted tasks for each list. A task is marked as completed if its **complete** property is true. You need to define a **map** function which:

1. Returns the number of uncompleted task documents,
2. Groups them by the list they belong to,
3. Counts the number of rows in each group.

The diagram below shows this process.

![](./img/image32.png)

Notice that **groupingLevel = 1** coalesces the rows in the view index by their key.

[Grouping](/documentation/mobile/current/develop/guides/couchbase-lite/native-api/query/index.html) is a powerful feature of Couchbase Lite. It is available on a **Query** using the **groupLevel** property, which is a number, and it defaults to 0. It basically takes the entire range of output that the query produces (i.e. the entire range of rows) and it coalesces together adjacent rows with the same key.

The most commonly used aggregation functions are Count and Sum:

- Count: A function that counts the number of documents contained in the map (used on the diagram above).
- Sum: A function that adds all of the items contained in the map.

The code below indexes documents as shown on the diagram above. Then it create the Query and monitors the result set using a Live Query.

```swift
// This code can be found in ListsViewController.swift
// in the setupViewAndQuery() method
let incompTasksCountView = database.viewNamed("list/incompleteTasksCount")
if incompTasksCountView.mapBlock == nil {
		incompTasksCountView.setMapBlock({ (doc, emit) in
				if let type: String = doc["type"] as? String , type == "task" {
						if let list = doc["taskList"] as? [String: AnyObject], let listId = list["id"],
								let complete = doc["complete"] as? Bool , !complete {
								emit(listId, nil)
						}
				}
				}, reduce: { (keys, values, reredeuce) in
				return values.count
		}, version: "1.0")
}

incompTasksCountsLiveQuery = incompTasksCountView.createQuery().asLive()
incompTasksCountsLiveQuery.groupLevel = 1
incompTasksCountsLiveQuery.addObserver(self, forKeyPath: "rows", options: .new, context: nil)
incompTasksCountsLiveQuery.start()
```

This time, you call emit only if the document `type` is "task" and `complete` is `false`. The document ID of the list it belongs to (**doc.taskList._id**) serves as the key and the value is nil. The reduce function simply counts the number of rows with the same key. Notice that the **groupLevel** is a property on the live query object.

Every time there is a change to `incompTasksCountsLiveQuery.rows` the `observeValueForKeyPath` method is called which will reload the list count for each row.

```swift
// This code can be found in ListsViewController.swift
// in the observeValue(forKeyPath:of:_:_:) method
override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
		if object as? NSObject == listsLiveQuery {
				reloadTaskLists()
		} else if object as? NSObject == incompTasksCountsLiveQuery {
				reloadIncompleteTasksCounts()
		}
}
```

#### Try it out

1. Build and run.
2. You will see the uncompleted task count for each list.

<img src="./img/image08.png" class="portrait" />

#### Conclusion

Well done! You've completed this lesson on using CRUD operations with the database and running aggregation queries. In the next lesson, you'll learn how to use Couchbase Lite's synchronization APIs with Sync Gateway. Feel free to share your feedback, findings or ask any questions on the forums.

In this lesson you’ll be introduced to Sync Gateway, our secure web gateway. You’ll learn how to use Couchbase Lite’s synchronization APIs, set up Sync Gateway for synchronization with the cloud and other devices, and resolve data conflicts within your application.

## Adding Synchronization

> **Tip:** To make things a bit more exciting, you may want to use the pre-built database containing a list of Groceries. Refer to the [Create a Database](/documentation/mobile/current/training/develop/using-the-database/index.html) lesson to learn how to use it.

### Install Sync Gateway

Now that your application runs smoothly on the device you are ready to introduce Sync Gateway. Create a new file called **sync-gateway-config.json** with the following.

```javascript
{
  "interface":":4984",
  "log": ["HTTP", "Auth"],
  "databases": {
    "todo": {
      "server": "walrus:",
      "users": {
        "GUEST": {"disabled": false, "admin_channels": ["*"] }
      }
    }
  }
}
```

During development, you can set the **server** property to **walrus:** (also known as the Walrus mode) and it will keep the data in memory. Note that anytime you restart Sync Gateway in walrus mode, the database will be empty.

By default, Sync Gateway doesn't allow unauthenticated requests to be processed for security reasons. So you're enabling the **GUEST** user which represents all the unauthenticated clients that will be synchronizing with your Sync Gateway instance.

> **Note:** User authentication is covered in more detail in the [Adding Security](/documentation/mobile/current/training/develop/adding-security/index.html) lesson.

Sync Gateway is always listening on two ports:

- 4984: the public port which will be used from the application.
- 4985: the admin port used for administrative tasks (for security reasons, it’s only accessible on localhost).

#### Try it out

1. [Download Sync Gateway](http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile)
2. Unzip the file and locate the executable at **bin/sync_gateway** (macOS) or run the installer (Windows).
3. Start Sync Gateway from the command-line in your project directory.

    ```bash
    sync_gateway sync-gateway-config.json
    ```
    
	```powershell
	PS> & 'C:\Program Files (x86)\Couchbase\sync_gateway.exe' sync-gateway-config.json
	```

    > **Note:** The Sync Gateway service might be running on Windows which will prevent this command from succeeding with the message 'FATAL: Failed to start HTTP server on 127.0.0.1:4985: listen tcp 127.0.0.1:4985: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.'  To get around this, stop the 'Couchbase Sync Gateway' service in 'services.msc'.

### Add synchronization

Typically, an application needs to send data to the server and receive it. In Couchbase Mobile, this is handled by replications which run on the device. A replication requires a Couchbase Lite database and a Sync Gateway URL, and synchronizes data between the two. They can be of two types:

- **Push:** The data is pushed from Couchbase Lite to Sync Gateway.
- **Pull:** The data is pulled from Sync Gateway to Couchbase Lite.

There are a few terminologies that designate the role of each database involved in a replications:

- **Source:** The database where the data is read.
- **Target:** The database where the data is written.
- **Local:** The database that resides where the replication is running.
- **Remote:** The database to which the replication is sending data.

The following code starts a pull and push replication with progress notifications.

<block class="ios" />

```swift
// This code can be found in AppDelegate.swift
// in the startReplication(withUsername:andPassword:)
pusher = database.createPushReplication(kSyncGatewayUrl)
pusher.continuous = true // Runs forever in the background
NotificationCenter.default.addObserver(self, selector: #selector(replicationProgress(notification:)),
                                        name: NSNotification.Name.cblReplicationChange, object: pusher)

puller = database.createPullReplication(kSyncGatewayUrl)
puller.continuous = true // Runs forever in the background
NotificationCenter.default.addObserver(self, selector: #selector(replicationProgress(notification:)),
                                        name: NSNotification.Name.cblReplicationChange, object: puller)

if kLoginFlowEnabled {
    let authenticator = CBLAuthenticator.basicAuthenticator(withName: username, password: password!)
    pusher.authenticator = authenticator
    puller.authenticator = authenticator
}

pusher.start()
puller.start()
```

<block class="net" />

```c#
// This code can be found in CoreApp.cs
// in the StartReplication(string, string) method
var authenticator = default(IAuthenticator);
if(username != null && password != null) {
    authenticator = AuthenticatorFactory.CreateBasicAuthenticator(username, password);
}

var db = AppWideManager.GetDatabase(username);
var pusher = db.CreatePushReplication(SyncGatewayUrl);
pusher.Continuous = true; // Runs forever in the background
pusher.Authenticator = authenticator;


var puller = db.CreatePullReplication(SyncGatewayUrl);
puller.Continuous = true; // Runs forever in the background
puller.Authenticator = authenticator;

pusher.Start();
puller.Start();

_pusher = pusher;
_puller = puller;
```

<block class="android" />

```java
// This code can be found in Application.java
// in the startReplication(String, String) method
URL url = null;
try {
    url = new URL(mSyncGatewayUrl);
} catch (MalformedURLException e) {
    e.printStackTrace();
}

pusher = database.createPushReplication(url);
pusher.setContinuous(true); // Runs forever in the background

puller = database.createPullReplication(url);
puller.setContinuous(true); // Runs forever in the background

if (mLoginFlowEnabled) {
    Authenticator authenticator = AuthenticatorFactory.createBasicAuthenticator(username, password);
    pusher.setAuthenticator(authenticator);
    puller.setAuthenticator(authenticator);
}

pusher.start();
puller.start();
```

<block class="all" />

#### Try it out

<block class="ios" />

1. In **AppDelegate.swift**, set `kSyncGatewayUrl` to the URL of the Sync Gateway database (http://localhost:4984/todo/).

    ```swift
    let kSyncGatewayUrl = URL(string: "http://localhost:4984/todo/")!
    ```

2. Set `kSyncEnabled` to `true` in **AppDelegate.swift**.

    ```swift
    let kSyncEnabled = true
    ```
    
3. Build and run.
4. Open [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo) in the browser and notice that all the documents are pushed to Sync Gateway! You may have more or less rows depending on how many documents are present in the Couchbase Lite database.

    <img src="./img/image19.png" />

<block class="net" />

1. In **CoreApp.cs** set `SyncGatewayUrl` to the URL of the Sync Gateway database (http://localhost:4984/todo/).

    ```c#
    private static readonly Uri SyncGatewayUrl = new Uri("http://localhost:4984/todo/");
    ```

2. In **CoreApp.cs** in the `CreateHint()` method, change `SyncEnabled = false` to `SyncEnabled = true`.

    ```c#
    var retVal = new CoreAppStartHint {
        LoginEnabled = false,
        EncryptionEnabled = false,
        SyncEnabled = true, // Line to change is here
        UsePrebuiltDB = false,
        ConflictResolution = false,
        Username = "todo"
    };

    return retVal;
    ```
    
3. Build and run.
4. Open [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo) in the browser and notice that all the documents are pushed to Sync Gateway! You may have more or less rows depending on how many documents are present in the Couchbase Lite database.

    <img src="./img/image19w.png" />

<block class="android" />

1. In **Application.java**, set `mSyncGatewayUrl` to the URL of the Sync Gateway database (http://localhost:4984/todo/).

    ```java
    private String mSyncGatewayUrl = "http://10.0.2.2:4984/todo/";
    ```

    For Android stock emulators, the hostname is `10.0.2.2`.

2. Set `mSyncEnabled` to `true` in **Application.java**.

    ```java
    private Boolean mSyncEnabled = true;
    ```
    
3. Build and run.
4. Open [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo) in the browser and notice that all the documents are pushed to Sync Gateway! You may have more or less rows depending on how many documents are present in the Couchbase Lite database.

    <img src="./img/image19a.png" />

<block class="all" />

### Resolve Conflicts

Due to the unpredictability of mobile connections it's inevitable that more than one device will update the same document simultaneously. Couchbase Lite provides features to resolve these conflicts. The resolution rules are written by the developer to keep full control over which revision should be picked. The most common resolution methods are:

- **Deletes always win:** if one side deletes a document it will always stay deleted, even if the other side has made changes to it later on.
- **N-way merge:** if both sides have updated different properties, the document will end up with the updates from both sides.
- **Last update wins:** if both sides have updated the same property, the value will end up as the last one that was updated.

Revisions form a tree data structure and a conflict occurs when there are multiple branches in the revision tree. On the diagram below the conflict is resolved by deleting one branch of the tree (the branch starting at **3-42cc**). The other one is the active branch (i.e the winner) where further child revisions can be persisted (**4-45cb** and **5-42bb**).

<img src="img/image16.png" class="portrait" />

#### Detecting conflicts

To resolve conflicts you must first learn how to detect them. The code below uses an All Docs query which is an index of all the documents in the local database. The **OnlyConflicts** option is passed to report only the documents with conflicts and a **LiveQuery** is used to continuously monitor the database for changes.

<block class="ios" />

```swift
// This code can be found in AppDelegate.swift
// in the startConflictLiveQuery() method
guard kConflictResolution else {
    return
}

conflictsLiveQuery = database.createAllDocumentsQuery().asLive()
conflictsLiveQuery!.allDocsMode = .onlyConflicts
conflictsLiveQuery!.addObserver(self, forKeyPath: "rows", options: .new, context: nil)
conflictsLiveQuery!.start()
```

The query results are then posted to the application code using the KVO observer method.

```swift
// This code can be found in AppDelegate.swift
// in the observeValue(forKeyPath:of:change:context:) method
override func observeValue(forKeyPath keyPath: String?, of object: Any?,
                            change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    if object as? NSObject == conflictsLiveQuery {
        resolveConflicts()
    }
}
```

<block class="net" />

```c#
// This code can be found in CoreApp.cs
// in the StartConflictLiveQuery() method
_conflictsLiveQuery = Database.CreateAllDocumentsQuery().ToLiveQuery();
_conflictsLiveQuery.AllDocsMode = AllDocsMode.OnlyConflicts;
_conflictsLiveQuery.Changed += ResolveConflicts;

_conflictsLiveQuery.Start();
```

<block class="android" />

```java
// This code can be found in Application.java
// in the startConflictLiveQuery() method
LiveQuery conflictsLiveQuery = database.createAllDocumentsQuery().toLiveQuery();
conflictsLiveQuery.setAllDocsMode(Query.AllDocsMode.ONLY_CONFLICTS);
conflictsLiveQuery.addChangeListener(new LiveQuery.ChangeListener() {
    @Override
    public void changed(LiveQuery.ChangeEvent event) {
        resolveConflicts(event.getRows());
    }
});
conflictsLiveQuery.start();
```

<block class="all" />

The query results are then posted to the application code using the change callback or change listener.

#### Automatic conflict resolution

Even if the conflict isn’t resolved, Couchbase Lite has to return something. It chooses one of the two conflicting revisions as the "winner". The choice is deterministic, which means that every device that is faced with the same conflict will pick the same winner, without having to communicate.

Shown below is a list document created with two conflicting revisions. After deleting the row, the text **Text Changed** appears which is the name of the second conflicting revision. The action of deleting a document only deletes the current revision and if there are conflicting revisions it will be promoted as the new current revision.

<block class="ios" />

<img src="https://cl.ly/0h3T1c0e1V2G/image47.gif" class="portrait" />

> **Note:** During development, the method `saveAllowingConflicts` is used to intentionally create a conflict. You can shake the device (**^⌘Z** on the simulator) to create a list conflict. The code is located in the `motionEnded(_:with:)` method of **ListsViewController.swift**.

<block class="wpf" />

<img src="https://cl.ly/0V2I0h1T1j24/image47w.gif" class="center-image" />

> **Note:** During development, the method `Save(bool)` is used to intentionally create a conflict. You can press Ctrl+C to create a list conflict. The code is located in the `TestConflict()` method of **TaskListsModel.cs**.

<block class="xam" />

**iOS**
<img src="./img/image47.gif" class="portrait" />
**Android**
<img src="./img/image47xa.gif" class="portrait" />

<block class="android" />

<img src="https://cl.ly/2h0Z2u2S0M1W/image47a.gif" class="portrait" />

> **Note:** During development, the method `save(boolean)` is used to intentionally create a conflict. You can long press the floating action button to create a list conflict. The code is located in the `createListConflict()` method of **ListsActivity.java**.

<block class="all" />

This can be surprising at first but it’s the strength of using a distributed database that defers the conflict resolution logic to the application. It’s your responsibility as the developer to ensure conflicts are resolved! Even if you decide to let Couchbase Lite pick the winner you must remove extraneous conflicting revisions to prevent the behaviour observed above. The code below removes all revisions except the current/winning one.

<block class="ios" />

```swift
// This code can be found in AppDelegate.swift
// in the resolveConflicts(revisions:withProps:andImage:) method
database.inTransaction {
    var i = 0
    for rev in revs as! [CBLSavedRevision] {
        let newRev = rev.createRevision()
        if (i == 0) { // Default winning revision
            newRev.userProperties = props
            if rev.attachmentNamed("image") != image {
                newRev.setAttachmentNamed("image", withContentType: "image/jpg",
                    content: image?.content)
            }
        } else {
            newRev.isDeletion = true
        }

        do {
            try newRev.saveAllowingConflict()
        } catch let error as NSError {
            NSLog("Cannot resolve conflicts with error: %@", error)
            return false
        }
        i += 1
    }
    return true
}
```

<block class="net" />

```c#
// This code can be found in CoreApp.cs
// in the ResolveConflicts(SavedRevision[], IDictionary<string, object>, Attachment) method
Database.RunInTransaction(() =>
{
    var i = 0;
    foreach(var rev in revs) {
        var newRev = rev.CreateRevision();
        if(i == 0) { // Default winning revision
            newRev.SetUserProperties(props);
            if(newRev.GetAttachment("image") != image) {
                newRev.SetAttachment("image", "image/jpg", image?.Content);
            }
        } else {
            newRev.IsDeletion = true;
        }

        try {
            newRev.Save(true);
        } catch(Exception e) {
            Debug.WriteLine($"Cannot resolve conflicts with error: {e}");
            return false;
        }

        i += 1;
    }

    return true;
});
```

<block class="android" />

```java
// This code can be found in Application.java
// in the resolveConflicts(List<SavedRevision>, Map<String, Object>, Attachment)
private void resolveConflicts(final List<SavedRevision> revs, final Map<String, Object> desiredProps, final Attachment desiredImage) {
    database.runInTransaction(new TransactionalTask() {
        @Override
        public boolean run() {
            int i = 0;
            for (SavedRevision rev : revs) {
                UnsavedRevision newRev = rev.createRevision(); // Create new revision
                if (i == 0) { // That's the current/winning revision
                    newRev.setUserProperties(desiredProps);
                    if (desiredImage != null) {
                        try {
                            newRev.setAttachment("image", "image/jpg", desiredImage.getContent());
                        } catch (CouchbaseLiteException e) {
                            e.printStackTrace();
                        }
                    }
                } else { // That's a conflicting revision, delete it
                    newRev.setIsDeletion(true);
                }

                try {
                    newRev.save(true); // Persist the new revision
                } catch (CouchbaseLiteException e) {
                    e.printStackTrace();
                    return false;
                }
                i++;
            }
            return true;
        }
    });
}
```

<block class="all" />

#### Try it out

<block class="ios" />

1. To enable conflict resolution, set the `kConflictResolution` constant in **AppDelegate.swift** to `true`.

    ```swift
    let kConflictResolution = true
    ```

2. Perform the same actions and this time deleting the list conflict doesn’t reveal the subsequent conflicting revision anymore.

    <img class="portrait" src="https://cl.ly/0b2y1o1U1L2u/image48.gif"  />

<block class="net" />

1. To enable conflict resolution, change `ConflictResolution = false` to `ConflictResolution = true` in the `CreateHint()` method in **CoreApp.cs**

   ```c#
   var retVal = new CoreAppStartHint {
       LoginEnabled = false,
       EncryptionEnabled = false,
       SyncEnabled = false,
       UsePrebuiltDB = false,
       ConflictResolution = true, // The line to change
       Username = "todo"
   };

   return retVal;
   ```
   
2. Perform the same actions and this time deleting the list conflict doesn’t reveal the subsequent conflicting revision anymore.

<block class="wpf" />

<img class="center-image" src="https://cl.ly/0o1z380g2w2w/image48w.gif"  />

<block class="xam" />

**iOS**
<img class="portrait" src="./img/image48.gif"  />
**Android**
<img class="portrait" src="./img/image48xa.gif"  />

<block class="android" />

1. To enable conflict resolution, set the `mConflictResolution` constant in **Application.java** to `true`.

    ```java
    private Boolean mConflictResolution = true;
    ```

2. Perform the same actions and this time deleting the list conflict doesn't reveal the subsequent conflicting revision anymore.

    <img class="portrait" src="https://cl.ly/1A0u402Z1t08/image48a.gif"  />

<block class="all" />

#### N-way conflict resolution

For task documents, you will follow the same steps as previously except this time the conflict resolution will merge the differences between the conflicting revisions into a new revision before removing them. This time, one revision changes the title of the task while the other revision marks it as completed.

<block class="ios" />

<img src="https://cl.ly/0q3A3F2E1Z2L/image67.gif" class="portrait" />

> **Note:** To see the same result, open any list and shake the device (**^⌘Z** on the simulator) to create a task conflict. The code is located in the `motionEnded(_:with:)` method of **TasksViewController.swift**. Be sure to disable conflict resolution to see the same result as the animation above.

<block class="wpf" />

<img src="https://cl.ly/451n2X1v1r0z/image67w.gif" class="center-image" />

> **Note:** To see the same result, open any list and press Ctrl+C to create a task conflict.  The code is located in the
`TestConflict()` method of **TasksModel.cs**.  Be sure to disable conflict resolution to see the same result as the animation above.

<block class="android" />

<img src="https://cl.ly/1E1O0M1l333r/image67a.gif" class="portrait" />

> **Note:** To see the same result, open any list and long press the floating action button to create a task conflict. The code is located in the `createTaskConflict()` method of **TasksFragment.java**. Be sure to disable conflict resolution to see the same result as the animation above.

<block class="all" />

Similarly to the previous section, you will learn how to resolve conflicts, this time for "task" documents. In this case, the resolution code will **merge the changes** (i.e n-way merge) of the conflicting revisions and promote the result as the current revision.

<block class="ios" />

```swift
// This code can be found in AppDelegate.swift
// in the resolveConflicts() method
let rows = conflictsLiveQuery?.rows
while let row = rows?.nextRow() {
    if let revs = row.conflictingRevisions, revs.count > 1 {
        let defaultWinning = revs[0]
        let type = (defaultWinning["type"] as? String) ?? ""
        switch type {
        // TRAINING: Automatic conflict resolution
        case "task-list", "task-list.user":
            let props = defaultWinning.userProperties
            let image = defaultWinning.attachmentNamed("image")
            resolveConflicts(revisions: revs, withProps: props, andImage: image)
        // TRAINING: N-way merge conflict resolution
        case "task":
            let merged = nWayMergeConflicts(revs: revs)
            resolveConflicts(revisions: revs, withProps: merged.props, andImage: merged.image)
        default:
            break
        }
    }
}
```

<block class="net" />

```c#
// This code can be found in CoreApp.cs
// in the ResolveConflicts() method
var rows = _conflictsLiveQuery?.Rows;
if(rows == null) {
    return;
}

foreach(var row in rows) {
    var conflicts = row.GetConflictingRevisions().ToArray();
    if(conflicts.Length > 1) {
        var defaultWinning = conflicts[0];
        var type = defaultWinning.GetProperty("type") as string ?? "";
        switch(type) {
            // TRAINING: Automatic conflict resolution
            case "task-list":
            case "task-list.user":
                var props = defaultWinning.UserProperties;
                var image = defaultWinning.GetAttachment("image");
                ResolveConflicts(conflicts, props, image);
                break;
            // TRAINING: N-way merge conflict resolution
            case "task":
                var merged = NWayMergeConflicts(conflicts);
                ResolveConflicts(conflicts, merged.Item1, merged.Item2);
                break;
            default:
                break;
        }
    }
}
```

<block class="android" />

```java
// This code can be found in Application.java
// in the resolveConflicts(QueryEnumerator) method
for (QueryRow row : rows) {
    List<SavedRevision> revs = row.getConflictingRevisions();
    if (revs.size() > 1) {
        SavedRevision defaultWinning = revs.get(0);
        String type = (String) defaultWinning.getProperty("type");
        switch (type) {
            // TRAINING: Automatic conflict resolution
            case "task-list":
            case "task-list.user":
                Map<String, Object> props = defaultWinning.getUserProperties();
                Attachment image = defaultWinning.getAttachment("image");
                resolveConflicts(revs, props, image);
                break;
            // TRAINING: N-way merge conflict resolution
            case "task":
                List<Object> mergedPropsAndImage = nWayMergeConflicts(revs);
                resolveConflicts(revs, (Map<String, Object>) mergedPropsAndImage.get(0), (Attachment) mergedPropsAndImage.get(1));
                break;
        }
    }
}
```

<block class="all" />

Notice that for 'task' documents, the `nWayMergeConflicts()` method is called to merge the differences of conflicting revisions. The body of this method is too long to copy here but you can find it in the same file.

#### Try it out

<block class="ios" />

1. Enable conflict resolution.

    ```swift
    let kConflictResolution = true
    ```

2. Build and run. 
3. Create a task conflict using the shake gesture (or **^⌘Z**) and this time the row contains the updated text **and** is marked as completed.
    <img src="img/image03.png" class="portrait" />
    
<block class="wpf" />

1. Enable conflict resolution

   ```c#
   var retVal = new CoreAppStartHint {
       LoginEnabled = false,
       EncryptionEnabled = false,
       SyncEnabled = false,
       UsePrebuiltDB = false,
       ConflictResolution = true, // The line to change
       Username = "todo"
   };

   return retVal;
   ```
   
2. Build and run
3. Create a conflict by pressing 'Ctrl+C' and this time the row contains the updated text **and** is marked as completed.

    ![](img/image03w.png)

<block class="xam" />

1. Enable conflict resolution

   ```c#
   var retVal = new CoreAppStartHint {
       LoginEnabled = false,
       EncryptionEnabled = false,
       SyncEnabled = false,
       UsePrebuiltDB = false,
       ConflictResolution = true, // The line to change
       Username = "todo"
   };

   return retVal;
   ```
   
2. Build and run
3. Create a task conflict using the shake gesture and this time the row contains the updated text **and** is marked as completed.

**iOS**
![](img/image03.png)
**Android**

<block class="android" />

1. Enable conflict resolution in **Application.java**.

    ```java
    private Boolean mConflictResolution = true;
    ```

2. Build and run.
3. Create a task conflict using the shake gesture and this time the row contains the updated text **and** is marked as completed.

    <image src="img/image03a.png" class="portrait" />

<block class="all" />

#### Conclusion

Well done! You've completed this lesson on enabling synchronization, detecting and resolving conflicts. In the next lesson you'll learn how to implement authentication and define access control rules in the Sync Function. Feel free to share your feedback, findings or ask any questions on the forums.

## Adding Security


### Install Sync Gateway

Users are created with a name/password on Sync Gateway which can then be used on the Couchbase Lite replicator to authenticate as a given user. You can create users by hardcoding the user's name/password in the configuration file. Create a new file called **sync-gateway-config.json** with the following.

```javascript
{
  "log": ["HTTP", "Auth"],
  "databases": {
    "todo": {
      "server": "walrus:",
      "users": {
        "user1": {"password": "pass", "admin_channels": ["user1"]},
        "user2": {"password": "pass", "admin_channels": ["user2"]},
        "mod": {"password": "pass", "admin_roles": ["moderator"]},
        "admin": {"password": "pass", "admin_roles": ["admin"]}
      },
      "roles": {
        "moderator": {},
        "admin": {}
      }
    }
  }
}
```

#### Try it out

1. [Download Sync Gateway](http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile)
2. Unzip the file and locate the executable at **~/Downloads/couchbase-sync-gateway/bin/sync_gateway**.
3. Start it from the command-line with the config file.

    ```bash
    $ /path/to/sync_gateway sync-gateway-config.json
    ```
	
    ```powershell
    PS> & 'C:\Program Files (x86)\Couchbase\sync_gateway.exe' sync-gateway-config.json
    ```

    > **Note:** The Sync Gateway service might be running on Windows which will prevent this command from succeeding with the message 'FATAL: Failed to start HTTP server on 127.0.0.1:4985: listen tcp 127.0.0.1:4985: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.'  To get around this, stop the 'Couchbase Sync Gateway' service in 'services.msc'.

4. Two users are now visible at [http://localhost:4985/_admin/db/todo/users](http://localhost:4985/_admin/db/todo/users).

### Replications with Authentication

With Sync Gateway users defined you can now enable authentication on the Couchbase Lite replicator. The code below creates two replications with authentication.

```swift
// This code can be found in AppDelegate.swift
// in the startReplication(withUsername:andPassword:) method
pusher = database.createPushReplication(kSyncGatewayUrl)
pusher.continuous = true
NotificationCenter.default.addObserver(self, selector: #selector(replicationProgress(notification:)),
    name: NSNotification.Name.cblReplicationChange, object: pusher)

puller = database.createPullReplication(kSyncGatewayUrl)
puller.continuous = true
NotificationCenter.default.addObserver(self, selector: #selector(replicationProgress(notification:)),
                                        name: NSNotification.Name.cblReplicationChange, object: puller)

if kLoginFlowEnabled {
    let authenticator = CBLAuthenticator.basicAuthenticator(withName: username, password: password!)
    pusher.authenticator = authenticator
    puller.authenticator = authenticator
}

pusher.start()
puller.start()
```

The `CBLAuthenticator` class has static methods for each authentication method supported by Couchbase Lite. Here, you're passing the name/password to the `basicAuthenticatorWithName` method. The object returned by this method can be set on the replication's `authenticator` property.

#### Try it out

1. Set `kSyncEnabled` and `kLoginFlowEnabled` to `true` in **AppDelegate.swift**.

    ```swift
    let kSyncEnabled = true
    let kLoginFlowEnabled = true
    ```

2. Build and run.

3. Now login with the credentials saved in the config file previously (**user1/pass**) and create a new list. Open the Sync Gateway Admin UI at [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo), the list document is successfully replicated to Sync Gateway as an authenticated user.

<img src="img/image35.png" class=center-image />

> **Note:** You can remove the local database and check if the pull replication retrieves the documents now present on Sync Gateway. On macOS, use the [SimPholders](https://simpholders.com/) utility app to quickly find the data directory of the application and delete the database called **user1** on iOS, or you can use the adb shell to navigate to the application's data folder and delete it on Android. Then restart the app and you'll notice that the "Today" list isn't displayed. That is, the list document wasn't replicated from Sync Gateway to Couchbase Lite. Indeed, the document is not routed to a channel that the user has access to. **Channel** and **access** are new terms so don't worry, we'll cover what they mean in the next section.

### Access Control

In order to give different users access to different documents, you must write a sync function. The sync function lives in the configuration file of Sync Gateway. It’s a JavaScript function and every time a new document, revision or deletion is added to a database, the sync function is called and given a chance to examine the document.

You can use different API methods to route documents to channels, grant users access to channels and even assign roles to users. Access rules generally follow the order shown on the image below: write permissions, validation, routing, read permissions.

![](img/image15.png)

> **Tip:** Open the [Access Control](/documentation/mobile/current/training/design/security/index.html) lesson in a new tab, it will be useful throughout this section.

### Document Types

The Sync Function takes two arguments:

- **doc:** The current revision being processed.
- **oldDoc:** The parent revisions if it's an update operation and `null` if it's a create operation.

Each document type will have different access control rules associated with it. So the first operation is to ensure the document has a type property. Additionally, once a document is created, its type cannot change. The code below implements those 2 validation rules.

```javascript
function(doc, oldDoc){
  /* Type validation */
  if (isCreate()) {
    // Don't allow creating a document without a type.
    validateNotEmpty("type", doc.type);
  } else if (isUpdate()) {
    // Don't allow changing the type of any document.
    validateReadOnly("type", doc.type, oldDoc.type);
  }

  if (getType() == "task-list") {
    /* Write access */
    /* Validation */
    /* Routing */
    /* Read Access */
  }

  function getType() {
    return (isDelete() ? oldDoc.type : doc.type);
  }

  function isCreate() {
    // Checking false for the Admin UI to work
    return ((oldDoc == false) || (oldDoc == null || oldDoc._deleted) && !isDelete());
  }

  function isUpdate() {
    return (!isCreate() && !isDelete());
  }

  function isDelete() {
    return (doc._deleted == true);
  }

  function validateNotEmpty(key, value) {
    if (!value) {
      throw({forbidden: key + " is not provided."});
    }
  }

  function validateReadOnly(name, value, oldValue) {
    if (value != oldValue) {
      throw({forbidden: name + " is read-only."});
    }
  }

  // Checks whether the provided value starts with the specified prefix
  function hasPrefix(value, prefix) {
    if (value && prefix) {
      return value.substring(0, prefix.length) == prefix
    } else {
      return false
    }
  }
}
```

As shown above, you can define inner functions to encapsulate logic used throughout the sync function. This makes your code more readable and follows the DRY principle (Don't Repeat Yourself).

#### Try it out

1. Open the Sync menu on the Admin UI [http://localhost:4985/_admin/db/todo/sync](http://localhost:4985/_admin/db/todo/sync).
2. Copy the code snippet above in the Sync Function text area.
3. Click the **Deploy To Server** button. It will update Sync Gateway with the new config but it doesn't persist the changes to the filesystem.
4. Add two documents through the REST API. One with the `type` property and the second document without it. Notice that the user credentials (**user1/pass**) are passed in the URL.

    ```bash
    curl -vX POST 'http://user1:pass@localhost:4984/todo/_bulk_docs' \
          -H 'Content-Type: application/json' \
          -d '{"docs": [{"type": "task-list", "name": "Groceries"}, {"names": "Today"}]}'
    ```

    The output should be the following:

    ```bash
    [
      {"id":"e498cad0380e30a86ed5572140c94831","rev":"1-e4ac377fc9bd3345ddf5892b509c4d79"},
      {"error":"forbidden","reason":"type is not provided.","status":403}
    ]
    ```
    
    > **Note:** The curl executable for Windows can be found [on this page](https://curl.haxx.se/download.html)

    The document without a type is rejected with an error message: "type property missing".

### Write Permissions

Once you know the type of a document, the next step is to check the write permissions.

The following code ensures the user creating the list document matches with the `owner` property or is a moderator.

```javascript
/* Write Access */
var owner = doc._deleted ? oldDoc.owner : doc.owner;
try {
  // Moderators can create/update lists for other users.
  requireRole("moderator");
} catch (e) {
  // Users can create/update lists for themselves.
  requireUser(owner);
}
```

When a document is deleted the user properties are removed and the `_deleted: true` property is added as metadata. In this case, the sync function must retrieve the type from oldDoc. In the code above, the `getType` inner function encapsulates this logic.

Similarly, the owner field is taken from oldDoc if doc is a deletion revision. The `requireUser` and `requireRole` functions are functionalities built in Sync Gateway.

#### Try it out

1. Open the Sync menu on the Admin UI [http://localhost:4985/_admin/db/todo/sync](http://localhost:4985/_admin/db/todo/sync).
1. Copy the changes above in the Sync Function text area to replace the `/* Write access */` block.
2. Click the **Deploy To Server** button. It will update Sync Gateway with the new config but it doesn't persist the changes to the filesystem.
3. Add two documents through the REST API. The request is sent as a user (**user1/pass**). One document is a list for user1 and another is a list for user2.

    ```bash
    curl -vX POST 'http://user1:pass@localhost:4984/todo/_bulk_docs' \
          -H 'Content-Type: application/json' \
          -d '{"docs": [{"type": "task-list", "owner": "user1"}, {"type": "task-list", "owner": "user2"}]}'
    ```

    The response should be the following:

    ```bash
    [
      {"id":"8339356c8bb6d8b32477e931ce04c5c9","rev":"1-39539a8ec6ddd252d6aafe1f7e3efd9a"},
      {"error":"forbidden","reason":"wrong user","status":403}
    ]
    ```

    The list with user2 as the owner is rejected.

### Validation

After write permissions, you must ensure the document has the expected schema. There are different types of validation such as checking for the presence of a field or enforcing read-only permission on parts of a document. The code below performs various schema validation operations.

```javascript
/* Validation */
if (!isDelete()) {
  // Validate required fields.
  validateNotEmpty("name", doc.name);
  validateNotEmpty("owner", doc.owner);

  if (isCreate()) {
    // Validate that the _id is prefixed by owner.
    if (!hasPrefix(doc._id, doc.owner + ".")) {
        throw({forbidden: "task-list id must be prefixed by list owner"});
    }
  } else {
    // Don’t allow task-list ownership to be changed.
    validateReadOnly("owner", doc.owner, oldDoc.owner);
  }
}
```

`validateNotEmpty` and `validateReadOnly` are inner functions to encapsulate common validation operations.

#### Try it out

1. Open the Sync menu on the Admin UI [http://localhost:4985/_admin/db/todo/sync](http://localhost:4985/_admin/db/todo/sync).
2. Copy the changes above in the Sync Function text area to replace the `/* Validation */` block.
3. Click the **Deploy To Server** button. It will update Sync Gateway with the new config but it doesn't persist the changes to the filesystem.

> **Challenge:** Persist documents using curl until it gets persisted and Sync Gateway returns a **201 Created** status code.

### Routing

Once you have determined that the schema is valid you can route the document to channels. A channel is a namespace for documents specifically designed for access control. The code below routes the document to its own list channel.

```javascript
/* Routing */
// Add doc to task-list's channel.
channel("task-list." + doc._id);
channel("moderators");
```

#### Try it out

1. Open the Sync menu on the Admin UI [http://localhost:4985/_admin/db/todo/sync](http://localhost:4985/_admin/db/todo/sync).
2. Copy the changes above in the Sync Function text area to replace the `/* Routing */` block.
3. Click the **Live Preview Mode** button. This mode doesn't restart Sync Gateway but will use the updated Sync Function for testing purposes. Click the **random** button to pick a document at random and run it through the sync function again. It re-calculates the routing to channels and access grants. This time, the owner (user1) has access to its own list's channel.
4. Both documents are saved and mapped to the corresponding channels in the Admin UI.

    ![](img/image88.png)

### Read Access

The last step in writing access control rules for a document type is to allow read access to channels. The following code grants the owner and users that are moderators access to the list's channel.

```javascript
/* Read Access */
// Grant task-list owner access to the task-list, its tasks, and its users.
access(owner, "task-list." + doc._id);
access(owner, "task-list." + doc._id + ".users");
access("role:moderator", "task-list." + doc._id);
```

#### Try it out

1. Open the Sync menu on the Admin UI [http://localhost:4985/_admin/db/todo/sync](http://localhost:4985/_admin/db/todo/sync).
2. Copy the changes above in the Sync Function text area to replace the `/* Read access */` block.
3. Click the **Live Preview Mode** button. This mode doesn't restart Sync Gateway but will use the updated Sync Function for testing purposes. Click the **random** button to pick a document at random and run it through the sync function again. It re-calculates the routing to channels and access grants. This time, the owner (user1) has access to its own list's channel.

    ![](img/image38.png)

### Conclusion

Well done! You've completed this lesson on adding authentication, writing a sync function and adding database encryption. Feel free to share your feedback, findings or ask any questions on the forums.

## Integration

### Changes stream

The changes stream returns a sorted list of changes made to documents in the database. It's the primary API to get notified of changes as they are processed by Sync Gateway and persisted to Couchbase Server.

Documents written to Sync Gateway are assigned a sequence value at write time. This sequence is used to order the changes feed. You can query the changes feed using a simple HTTP GET request to `/{db}/_changes` as shown below.

```bash
$ curl -H 'Content-Type: application/json' -vX GET 'http://localhost:4985/todo/_changes?since=3'
```

> **Note:** The curl executable for Windows can be found [on this page](https://curl.haxx.se/download.html)

The **since** parameter in the querystring is used to specify which sequence to start from. In this case the response contains changes starting at `seq: 3` because the `since=3` parameter was sent in the querystring.

Deleting a document creates a new revision with the `deleted: true` property and no user properties. This is required in order to propagate the deletion to other devices. In the example above the change with sequence 4 (`seq: 4`) is a deletion.

#### Try it out

<block class="ios" />

1. Download Sync Gateway and start it with the configuration file in the root directory of the accompanying project.

    ```bash
    ~/Downloads/couchbase-sync-gateway/bin/sync_gateway sync-gateway-config.json
    ```

	
	```powershell
	PS> & 'C:\Program Files (x86)\Couchbase\sync_gateway.exe' sync-gateway-config.json
	```

> **Note:** The Sync Gateway service might be running on Windows which will prevent this command from succeeding with the message 'FATAL: Failed to start HTTP server on 127.0.0.1:4985: listen tcp 127.0.0.1:4985: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.'  To get around this, stop the 'Couchbase Sync Gateway' service in 'services.msc'.


<block class="ios" />

2. Open **AppDelegate.swift** and set the following constants to `true`.

    ```swift
    let kLoginFlowEnabled = true
    let kSyncEnabled = true
    ```

3. Run the application, login with the **user1/pass** credentials and add a new list. It should appear as a new document on the Admin UI of Sync Gateway on [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo).

4. To access the changes stream (also called the changes feed). Open a browser tab at [http://localhost:4985/todo/_changes](http://localhost:4985/todo/_changes).

    ![](img/image54.png)
    
<block class="net" />

1. Download Sync Gateway and start it with the configuration file in the root directory of the accompanying project.

    ```bash
    ~/Downloads/couchbase-sync-gateway/bin/sync_gateway sync-gateway-config.json
    ```

    ```powershell
    PS> & 'C:\Program Files (x86)\Couchbase\sync_gateway.exe' sync-gateway-config.json
    ```

    > **Note:** The Sync Gateway service might be running on Windows which will prevent this command from succeeding with the message 'FATAL: Failed to start HTTP server on 127.0.0.1:4985: listen tcp 127.0.0.1:4985: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.'  To get around this, stop the 'Couchbase Sync Gateway' service in 'services.msc'.

2. Open **CoreApp.cs** and change the `CreateHint()` method as follows:

    ```c#
    var retVal = new CoreAppStartHint {
      LoginEnabled = true, // This line needs to be changed
      EncryptionEnabled = false,
      SyncEnabled = true, // This line needs to be changed
      UsePrebuiltDB = false,
      ConflictResolution = false,
      Username = "todo"
    };

    return retVal;
    ```

3. Run the application, login with the **user1/pass** credentials and add a new list. It should appear as a new document on the Admin UI of Sync Gateway on [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo).

4. To access the changes stream (also called the changes feed). Open a browser tab at [http://localhost:4985/todo/_changes](http://localhost:4985/todo/_changes).

    ![](img/image54.png)

<block class="android" />

1. Download Sync Gateway and start it with the configuration file in the root directory of the accompanying project.

    ```bash
    ~/Downloads/couchbase-sync-gateway/bin/sync_gateway sync-gateway-config.json
    ```

2. Open **Application.java** and set the following constants to `true`.

    ```swift
    let mLoginFlowEnabled = true
    let mSyncEnabled = true
    ```

3. Run the application, login with the **user1/pass** credentials and add a new list. It should appear as a new document on the Admin UI of Sync Gateway on [http://localhost:4985/_admin/db/todo](http://localhost:4985/_admin/db/todo).

4. To access the changes stream (also called the changes feed). Open a browser tab at [http://localhost:4985/todo/_changes](http://localhost:4985/todo/_changes).

<block class="all" />

### Subscribing to changes

In this section you will write a script to subscribe to changes continuously. This becomes particularly useful for integrating Couchbase Mobile with other systems.

To be notified of a change as it happens, an HTTP socket must remain open between the client and Sync Gateway. The `feed` querystring option is used in this case and there are 2 different feed types:

- **longpoll**: The response will contain all the changes since the specified sequence. If seq is the last sequence number (the most recent one) then the connection will remain open until a new document is processed by Sync Gateway and the change event is sent.
- **continuous**: In this case, Sync Gateway will hold the connection open forever.

To subscribe to the changes feed you can use any HTTP library to send the `GET /_changes` request with query options. In this lesson however you will use the generated libraries based on the Swagger specs. The code below sends a request to the changes stream every time a response has been received and processed. The `getChanges(seq)` method is called recursively passing the `last_seq` property received in the response as the `since` value in the subsequent request.

```javascript
var Swagger = require('swagger-client')
  , fs = require('fs')
  , spec = require('./spec');

// Use the SwaggerJS module to dynamically load the Swagger spec
new Swagger({
  spec: spec,
  usePromise: true
})
  .then(function (res) {
    client = res;
    
    // Start getting changes at seq: 0
    getChanges(0);
    
    function getChanges(seq) {
      // Use the Swagger client to connect to the changes feed
      client.database.get_db_changes({db: 'todo', include_docs: true, since: seq, feed: 'longpoll'})
        .then(function (res) {
          var results = res.obj.results;
          console.log(results.length + ' change(s) received');
          processChanges(results);
          // Get changes since the last sequence
          getChanges(res.obj.last_seq);
        })
        .catch(function (err) {
          console.log(err);
        });
    }

  });
```

Notice that the `get_db_changes` method is used with `since: <seq>` and `feed: longpoll` to get a set of changes since a specified sequence. The `include_docs: true` option is used to include the document body in the response.

#### Try it out

1. Open a Terminal window in the **bot** directory, install the dependencies and start the bot.

    ```bash
    npm install
    node app.js
    ```

2. Make further changes in the application and notice that the number of changes are printed to the console.

<block class="ios" />

  ![](https://cl.ly/1X0M0J2Q450U/image55.gif)

<block class="wpf" />

  ![](https://cl.ly/0R1q0U1G2i0K/image55w.gif)

<block class="all" />

### Bulk operations

In this section you will learn how to persist an image as an attachment using the Admin REST API. You will extend the changes feed handling code from the previous section to attach the image to a **task** document only if the text value is "apple", "coffee" or "potatoes".

Similarly to the previous section, you will use the API methods available on the library provided by Swagger.

```javascript
function processChanges(results) {
  for (var i = 0; i < results.length; i++) {
    var doc = results[i].doc;
    var img;
    if (doc && !doc._deleted && doc.type == 'task' && !doc._attachments) {
      switch (doc.task.toLowerCase()) {
        case 'apple':
          img = fs.readFileSync('apple.png');
          break;
        case 'coffee':
          img = fs.readFileSync('coffee.png');
          break;
        case 'potatoes':
          img = fs.readFileSync('potatoes.png');
          break;
      }
      if (img) {
        var base64 = img.toString('base64');
        doc._attachments = {
          image: {
            content_type: 'image\/png',
            data: base64
          }
        };
        client.database.post_db_bulk_docs({db: 'todo', BulkDocsBody: {docs: [doc]}})
          .then(function (res) { 
            console.log('1 change posted');
          })
          .catch(function (err) {
            console.log(err);
          });
      }
    }
  }
}
```

This code checks that the change is not a deletion and that the document type is "task". If the `doc.task` property is either "apple", "coffee" or "potatoes" then it reads the corresponding image as a Base64 string and sets it on the document's `_attachments` dictionary. Finally it persists the document with the attachment back to Sync Gateway using the `post_db_bulk_docs` method.

#### Try it out

1. Run the application and make sure it's replicating to Sync Gateway.
2. Start the bot.

    ```bash
    node app.js
    ```

3. Add a task called "Apple", "Coffee" or "Potatoes" and an image should appear after a few seconds. That's the attachment that was added to Sync Gateway by the bot and in turn replicated to Couchbase Lite.

<block class="ios" />

  <img src="https://cl.ly/060e3a0p3717/image56.gif" />

<block class="wpf" />

  <img src="https://cl.ly/3z3Q2v1n0n0d/image56w.gif" />

<block class="all" />

### Conclusion

Well done! You've completed this lesson on integration by using the Stream API to subscribe to changes and the REST API to persist a document back to Sync Gateway. Feel free to share your feedback, findings or ask any questions on the forums.